<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Siyu Tan - Leetcode</title>
  <meta name="author" content="Siyu Tan" />
  <meta name="description" content="The blog of Siyu Tan" />
  <link rel="canonical" href="http://localhost:4000/blog/2018/11/19/leetcode.html" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="alternate" type="application/atom+xml" title="Siyu Tan" href="http://localhost:4000/atom.xml" />

  <link rel="stylesheet" href="/assets/css/all.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
</head>
<body>
  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <h1>Hi.</h1>
  <a href="/">
    
    <img class="avatar" src="/logo.jpeg" id="logo" alt="Blog logo"/>
    
  </a>
  <h2>I'm <a href="/">Siyu Tan</a>.</h2>
  <div id="bio">
    <p>Suuuuupppper cuuuuuute!!!</p>
    <p><a href="/">Blog Posts</a></p>
  </div>
  
  <div id="social">
    Follow me:
<div id="stalker">
  
  <a title="siyuboomboom on Github" href="https://github.com/siyuboomboom">
    <i class="fa fa-github-square"></i>
  </a>
  

  

  

  

  

  

  
  <a title="Siyu Tan on Facebook" href="https://facebook.com/sherry.tan.92351">
    <i class="fa fa-facebook-square"></i>
  </a>
  

  

  
  <a title="Siyu Tan on LinkedIn" href="https://www.linkedin.com/in/siyutan">
    <i class="fa fa-linkedin-square"></i>
  </a>
  

  

  
</div>

  </div>
</nav>

    </div>

    <div class="eleven columns content">
      <p class="meta">
  November 19, 2018 
  <a href="/">
    <i class="home fa fa-home"></i>
  </a>
</p>

<h1 class="title">Leetcode</h1>

<div id="post">
  <h3 id="88-merge-sorted-array">88. Merge Sorted Array</h3>
<p>Array A length: n, B length: m<br />
Brute Force: <strong>O(n * m)</strong>, compare from left, insert one by one at the front, shift to the right.<br />
Since the empty spots are at right side, how about comparing from right?<br />
Time complexity: <strong>O(n + m)</strong></p>

<hr />
<h3 id="4-median-of-two-sorted-arrays">4. Median of Two Sorted Arrays</h3>
<p><strong>Approach 1: Find kth: O(log(m + n))</strong><br />
Find median problem can be generalized to find kth smallest number.
Let’s say array A has n numbers, B has m numbers.</p>
<ol>
  <li>Compare (k/2)th numbers in both arrays.</li>
  <li>Drop the left part of the smaller number, since we are sure the kth number is not in that part.</li>
  <li>k = k - k / 2 (careful: not k = k / 2), continue 1 and 2 until k = 1.</li>
</ol>

<p><img src="/assets/images/i2.png" width="600" /></p>

<p>In the step 1, if A is short of k / 2 numbers:
<img src="/assets/images/i3.png" width="600" />
One thing we are sure about is that the kth number is not in the first k / 2 numbers of B. So drop that part of B.<br />
Imagine both arrays extended to infinite length, followed by infinite numbers of Integer.MAX_VALUE. This doesn’t affect the result of finding kth smallest number. So if the startIndex + k / 2 is out of bound, just assume the element is Integer.MAX_VALUE.</p>

<hr />
<h3 id="139-subarray-sum-closest">139. Subarray Sum Closest</h3>
<p>To find the subarray sum closest to 0 instead of 0, brute force is O(n^2) which is to find all subarrays. It’s impossible to achieve O(n). We can consider calculating all prefix sums and sort them so that the adjacent prefix sums produce the minimum difference. Minimum difference between two prefix sums means closest subarray sum. Then we need to get the corresponding index to those two prefix sums. To do this, we can write a wrapper class to wrap the prefix sum and its index. <br />
Time Complexity: <strong>O(nlogn)</strong></p>

<hr />
<h3 id="325-maximum-size-subarray-sum-equals-k">325. Maximum Size Subarray Sum Equals k</h3>
<p><strong>Prfix Sum</strong>
<code class="highlighter-rouge">Sum of a subarray[i : j] = prefixSum[j + 1] - prefixSum[i]</code><br />
To find a subarray sum equals k, it means <code class="highlighter-rouge">prefixSum[j + 1] = prefixSum[i] + k</code> <br />
We can use a HashMap to store each prefixSum and its index. If there’s a duplicate prefixSum, just ignore it because we need to find the maximum length.</p>

<hr />
<h3 id="53-maximum-subarray">53. Maximum Subarray</h3>
<p>Brute force is O(n^2) because there are n ^ 2 subarrays.<br />
<strong>Approach 1: dynamic programming O(n)</strong><br />
<code class="highlighter-rouge">int[] dp = new dp[nums.length];</code> <br />
dp[i] denotes the max sum of subarray ends with nums[i]. So we have:<br />
<code class="highlighter-rouge">dp[i + 1] = dp[i] &gt; 0 ? dp[i] + nums[i + 1] : nums[i + 1];</code><br />
Maximum subarray sum is maximum of dp array. Since we don’t need the previous dp elements, we can optimize the space by using <code class="highlighter-rouge">int dp</code> instead of an array.</p>

<p><strong>Approach 2: prefix sum O(n)</strong> <br />
prefixSum[i + 1] denotes the sum of the first i + 1 elements, i.e. subarray[0 : i]. <br />
<code class="highlighter-rouge">Sum of a subarray[i : j] = prefixSum[j + 1] - prefixSum[i]</code><br />
For each subarray ending with nums[j], the maximum subarray sum depends on finding the minimum prefixSum[i].</p>

<hr />
<h3 id="215-kth-largest-element-in-an-array">215. Kth Largest Element in an Array</h3>
<p><strong>Quick Select</strong><br />
Use the thought in quick sort, where we partition the array by two parts based on comparison with a pivot. In quick sort, we continue sorting in two parts, while in this problem, we don’t care about another part if it doesn’t consist of the kth largest element. So after partition, we can drop half of the array on average.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">T</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">=</span> <span class="n">O</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">+</span> <span class="n">T</span><span class="o">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
     <span class="o">=</span> <span class="n">O</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">+</span> <span class="n">O</span><span class="o">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">O</span><span class="o">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">4</span><span class="o">)</span> <span class="o">+</span> <span class="o">..</span> <span class="o">+</span> <span class="n">O</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
     <span class="o">=</span> <span class="n">O</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> </code></pre></figure>

<hr />
<h3 id="lintcoe-545-top-k-largest-numbers-ii">LintCoe 545. Top k Largest Numbers II</h3>

<p>Complexity Analysis:</p>

<table>
  <thead>
    <tr>
      <th>Approach</th>
      <th>add() Time</th>
      <th>topk() Time</th>
      <th>Space Complexity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>quick select</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>min heap</td>
      <td>O(logk)</td>
      <td>O(klogk)</td>
      <td>O(k)</td>
    </tr>
    <tr>
      <td>max heap</td>
      <td>O(logn)</td>
      <td>O(klogn)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>sort</td>
      <td>O(1)</td>
      <td>O(nlogn)</td>
      <td>O(n)</td>
    </tr>
  </tbody>
</table>

<p>Obviously, max heap and sort approaches are worse than the other two. There’s no need to keep all numbers in heap.<br />
It depends on how big the k is to decide which one of quick select and min heap is better. If n » k, min heap is better, vice versa.</p>

<hr />
<h3 id="lintcode-612-k-closest-points">LintCode 612. K Closest Points</h3>
<p><strong>Approach 1: Brute Force</strong><br />
Calculate distance and sort by distance.<br />
Time Complexity: <strong>O(nlogn)</strong></p>

<p><strong>Approach 2: Quick Select</strong><br />
Time Complexity:</p>

<p><strong>Approach 3: Heap</strong><br />
Write a comparator to make the least closest point be root of the heap. Add each point to the heap, once the size is greater than k, poll the least closest point. <br />
Time Complexity: <strong>O(nlogk + klogk)</strong><br />
At most k points be in heap, and we offer n points to heap. After that, poll all k closest points into results.</p>

<p><strong>Approach 4: Heapify</strong><br />
Time Complexity: <strong>O(n + klogn)</strong><br />
When n » k, it’s very fast.</p>

<hr />

<h3 id="23-merge-k-sorted-lists">23. Merge k Sorted Lists</h3>
<p>Signature of the method:<br />
<code class="highlighter-rouge">public ListNode mergeKLists(ListNode[] lists)</code><br />
Intuitive thinking is to compare each head node in the lists, add the smallest one to result, and make the next node of the smallest one to be the new head. <br />
So the brute force method costs <strong>O(nk)</strong>, n is the total number of nodes in all lists, k is the number of lists.  <br />
When k is very large, accurately if bigger than logn, it’s even worse than merging all lists at the first place and sort the whole list, which costs O(nlogn).</p>

<p><strong>Approach 1: PriorityQueue</strong><br />
Add each node in the array into the heap, everytime we poll, we get the min value node of the k nodes. Then we add the next node of that min node to heap unless it’s null.<br />
KEY: Since the elements in PriorityQueue are ListNode, we have to pass in a comparator to the PQ.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="n">lists</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> 
                                                    <span class="k">new</span> <span class="nf">NodeComparator</span><span class="o">());</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NodeComparator</span> <span class="kd">implements</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">n1</span><span class="o">,</span> <span class="n">ListNode</span> <span class="n">n2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">n1</span><span class="o">.</span><span class="na">val</span> <span class="o">-</span> <span class="n">n2</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Also, the maximum number of elements will be k which is the number of the sorted lists.<br />
Time Complexity: <strong>O(nlogk)</strong> <br />
n is total number of elements, k is number of sorted lists. <br />
There will be at most k nodes in the heap, so the hight of the heap is logk, and add and poll a node into and from it costs O(logk), and we do that for n times.</p>

<p><strong>Approach 2: Bottom-up pair by pair merge</strong><br />
As in the following picture, starting from the bottom, we merge each pair of lists, and merge the merged lists in pairs, and do that recursively. In this way, every level up, it costs O(n), and there are logk levels, so the time complexity is <strong>O(nlogk)</strong><br />
<img src="/assets/images/i1.png" width="800" /></p>

<p><strong>Approach 3: Divide and Conquer (like Merge Sort)</strong><br />
It’s actually quite like approach 2, only implement the top-down process with a recursion (divide). Approach 2 starts from the bottom, using an iteration to go through the array of ListNode pair by pair. Approach 3 starts from the top, viewing the array as a whole and divide it by 2 recursively until only one node is left. And then merge like in the approach 2.</p>

<hr />
<h3 id="264-ugly-number-ii">264. Ugly Number II</h3>
<p><strong>Approach 1</strong><br />
Use a PriorityQueue as a min heap. The heap starts with 1 in it. Get a min value from the heap and multiply it with 2, 3, 5 and add the results to the heap. Every time poll() we can get a min value which ensures the order. <br />
However, this process generates duplicates, eg. 2 * 3 = 3 * 2.<br />
PriorityQueue allows duplicates so HashSet can be used to ensure there’s no duplicates in the heap.</p>

<p>Note: be aware of integer overflow!! <br />
Imagine in the final round, min value is supposed to be say 536,870,912, but the heap still contains many numbers that are greater than this min, which may exceeds the upper bound of integer. This will cause negative numbers in the heap and these negative numbers will become the min value.</p>

<p>Time complexity: <strong>O(nlogn)</strong><br />
Everytime we poll a number, we add it multiplied by 2, 3, 5 into the heap. Add operation for heap is O(logn). And we need to poll n times to find the nth ugly number.</p>

<p><strong>Approach 2</strong><br />
Imagin a list of ugly numbers 1, 2, 3, 4, 5, 6, 8, 9, … <br />
And 3 pointers for multipliers 2, 3, 5, corresponding p2, p3, p5, all pointing at 1. After we multiply 1 by 2, 3, 5, we add the min value to the list which is 2, and we move the p2 to the next element which is 2, since we already multiplied the 1 with 2. Later, we compare 2 * 2, 1 * 3, 1 * 5, and we add 3, and move p3 to next… <br />
Time complexity: <strong>O(n)</strong></p>

<hr />
<h3 id="380-insert-delete-getrandom-o1">380. Insert Delete GetRandom O(1)</h3>
<p>Design a data structure that supports all following operations in average O(1) time.</p>
<ol>
  <li>insert(val)</li>
  <li>remove(val)</li>
  <li>getRandom</li>
</ol>

<p>Consider 3 possible data structure:</p>
<ol>
  <li>LinkedList: insert and remove are O(1), but for getRandom, we have to iterate to a random node which takes O(n)</li>
  <li>HashMap: insert and remove are O(1), but can’t get a random number from it.</li>
  <li>ArrayList: insert and getRandom are O(1), but remove takes O(n) because of shifting.</li>
</ol>

<p>We can consider a combination of ArrayList and HashMap. To find the index of the value to be removed in O(1), we can use a HashMap to store the value and its corresponding index. To avoid shifting caused by remove(), we can just move the last element to replace the removed one, since we don’t care the order.</p>

<hr />
<h3 id="146-lru-cache">146. LRU Cache</h3>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations:</p>
<ol>
  <li>get(key)</li>
  <li>put(key, value)</li>
</ol>

<p>It’s natural to think of LinkedList which is fast to insert and delete a node, whereas an array takes O(n) to delete a element in the middle and maintain the order at the same time.<br />
For get(), we need to find the node and move it to the front.<br />
For put(), we also need to find the node and update it or create a new node and move it to the front. If it reaches the capacity, we need to delete the oldest node at the end.<br />
LinkedList takes O(1) to delete and insert a node. But it takes O(n) to find the node. To improve the performance to O(1), a HashMap can store the mapping between the key and the node.<br />
However, to delete a node, we have to know the previous node. Doubly linked list can solve the problem, but a more concise way is to store the mapping between the key and the previous node. <br />
Therefore, a <strong>LinkedList and a HashMap</strong> can implement the get and put operation in <strong>O(1)</strong>.<br />
LinkedHashMap can help.</p>

<hr />
<h3 id="387-first-unique-character-in-a-string">387. First Unique Character in a String</h3>
<p>It’s easy to solve the problem in O(n) using HashMap or an array of size 26. <br />
Let’s consider its follow-up question: iterate through the string for only once. Like to get the first unique character in a stream, where add and getFirstUnique operation both take O(1).</p>

<p>We can use the same thought in LRU cache with a combination of HashMap and LinkedList.<br />
Let’s maintain a LinkedList of characters that are unique, and the head of the list is the first unique char. HashMap stores the information about which node the char is in. Once a new char comes in which is already in the HashMap, we just delete the node.</p>

<hr />
<h3 id="4-median-of-two-sorted-arrays-1">4. Median of Two Sorted Arrays</h3>
<p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/">https://leetcode.com/problems/median-of-two-sorted-arrays/description/</a></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">double</span> <span class="nf">findMedianSortedArrays</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    
    <span class="c1">// odd number</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">findKth</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// even number</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">findKth</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">findKth</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">/</span> <span class="mf">2.0</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// find the kth smallest number in the two arrays</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="nf">findKth</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">start1</span> <span class="o">&gt;=</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">nums2</span><span class="o">[</span><span class="n">start2</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
    
    <span class="k">if</span> <span class="o">(</span><span class="n">start2</span> <span class="o">&gt;=</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">nums1</span><span class="o">[</span><span class="n">start1</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
    
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">nums1</span><span class="o">[</span><span class="n">start1</span><span class="o">],</span> <span class="n">nums2</span><span class="o">[</span><span class="n">start2</span><span class="o">]);</span>
    <span class="o">}</span>
    
    <span class="kt">int</span> <span class="n">half1</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">half2</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    
    <span class="k">if</span> <span class="o">(</span><span class="n">start1</span> <span class="o">+</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nums1</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">half1</span> <span class="o">=</span> <span class="n">nums1</span><span class="o">[</span><span class="n">start1</span> <span class="o">+</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
    
    <span class="k">if</span> <span class="o">(</span><span class="n">start2</span> <span class="o">+</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">half2</span> <span class="o">=</span> <span class="n">nums2</span><span class="o">[</span><span class="n">start2</span> <span class="o">+</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
    
    <span class="k">if</span> <span class="o">(</span><span class="n">half1</span> <span class="o">&gt;</span> <span class="n">half2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">findKth</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">start1</span><span class="o">,</span> <span class="n">nums2</span><span class="o">,</span> <span class="n">start2</span> <span class="o">+</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span> 
    
    <span class="k">return</span> <span class="nf">findKth</span><span class="o">(</span><span class="n">nums1</span><span class="o">,</span> <span class="n">start1</span> <span class="o">+</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">nums2</span><span class="o">,</span> <span class="n">start2</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">k</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<hr />

<h3 id="50-powx-n">50. Pow(x, n)</h3>
<p><a href="https://leetcode.com/problems/powx-n/description/">https://leetcode.com/problems/powx-n/description/</a></p>

<p>Recursive method is relatively easy. Lets discuss about the iterative one.<br />
Let’s consider the exponent n in binary representation. Say, n = 9</p>

<p><code class="highlighter-rouge">9 = (1001)2 = 2 ^ 3 + 2 ^ 0</code></p>

<p>Therefore, pow(x, 9) equals<br />
<code class="highlighter-rouge">x ^ 9 = x ^ (2 ^ 3 + 2 ^ 0) = (x ^ (2 ^ 3)) * (x ^ (2 ^ 0))</code></p>

<p>So if <strong>ith</strong> bit is 1, we multiply the ans by <code class="highlighter-rouge">x ^ (2 ^ i)</code>. (the least significant is 0th) <br />
For <code class="highlighter-rouge">i = 0, 1, 2, ...</code>, we multiply the ans by <code class="highlighter-rouge">x ^ 1, x ^ 2, x ^ 4, x ^ 8, ...</code></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">double</span> <span class="nf">myPow</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">double</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">long</span> <span class="n">absN</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">((</span><span class="kt">long</span><span class="o">)</span><span class="n">n</span><span class="o">);</span>
    
    <span class="k">while</span> <span class="o">(</span><span class="n">absN</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">absN</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ans</span> <span class="o">*=</span> <span class="n">x</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">absN</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>Note:<br />
When calculating absolute values, be careful with the integer overflow. Turn it into long in advance.</p>

<hr />
<h3 id="230-kth-smallest-element-in-a-bst">230. Kth Smallest Element in a BST</h3>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">https://leetcode.com/problems/kth-smallest-element-in-a-bst/</a></p>

<p><strong>Approach 1: Inorder Traversal - Iterative</strong></p>

<p><strong>Time complexity:</strong>  <br />
O(max(k, h)), minimum time will be on average O(h) because we need to go all the way down to the leftmost node and then starting counting till k. <br />
<strong>Space complexity</strong>: <br />
O(h), h is height of the tree</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
    <span class="n">TreeNode</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">curr</span><span class="o">);</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
        <span class="n">k</span><span class="o">--;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">TreeNode</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">ptr</span><span class="o">);</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p><strong>Approach 2: Add a count field in node - recursive</strong></p>

<p>If the BST is modified (insert/delete operations) often and we need to find the kth smallest frequently…   <br />
O(k) is too slow in the case when k is closer to number of nodes.   <br />
If we can reconstruct the node structure of the tree, we can add a count field to indicate the number of nodes in the node’s subtree, including itself.</p>

<p><strong>Time complexity</strong>: <br />
kthSmallest(): O(h), h is the height of the tree, because each recursion we can go one level deeper by choosing left of right subtree.<br />
insert/delete operation: O(h), O(h) to find the right place to insert/detele and O(h) to update each upper level parent’s count. <br />
<strong>Space complexity</strong>: <br />
O(1). (Not counting the space of the new tree because imagine we edit the original tree structure to include the count field in the first place)</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">newRoot</span> <span class="o">=</span> <span class="n">buildCountTree</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">newRoot</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">count</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">kthSmallest</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="n">Node</span> <span class="nf">buildCountTree</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">buildCountTree</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">buildCountTree</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">root</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">root</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
        <span class="n">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>
        
        <span class="n">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

</div>

<div id="related">
  <h3>Related Posts</h3>
  <ul class="posts">
    
    <li>
      <span>06 Jan 2019 &raquo;</span> <a href="/blog/2019/01/06/multithread.html">Multithread</a>
    </li>
    
    <li>
      <span>06 Jan 2019 &raquo;</span> <a href="/blog/2019/01/06/linux-command.html">Linux Common Command</a>
    </li>
    
    <li>
      <span>06 Jan 2019 &raquo;</span> <a href="/blog/2019/01/06/consistent-hashing.html">Consistent Hashing</a>
    </li>
    
  </ul>
</div>


      <div class="footer">
        <div class="disclaimer">
  
  <p>
    The postings on this site are my own and don't necessarily represent my 
    employer’s positions, strategies or opinions.
  </p>
  

  <p>
    © Siyu Tan, 2019 &mdash; built with <a href="http://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/swanson/lagom">Lagom theme</a>
  </p>
</div>
      </div>
    </div>
  </div>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-xxxx-x']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
